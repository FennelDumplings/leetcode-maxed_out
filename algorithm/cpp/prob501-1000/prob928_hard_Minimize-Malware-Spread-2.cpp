// prob928: Minimize Malware Spread II

/*
 * https://leetcode-cn.com/problems/minimize-malware-spread-ii/
 */

#include <vector>
#include <unordered_set>

using namespace std;

class UnionFindSet
{
public:
    UnionFindSet(int n)
    {
        _father.assign(n, -1);
        for(int i = 0; i < n; ++i)
            _father[i] = i;
        _rank.assign(n, 0);
        _weight.assign(n, 1);
        _label.assign(n, 0);
    }

    int get_weight(int x)
    {
        return _weight[_find(x)];
    }

    void set_label(int x)
    {
        ++_label[_find(x)];
    }

    int get_label(int x)
    {
        return _label[_find(x)];
    }

    void merge(int x, int y)
    {
        x = _find(x);
        y = _find(y);
        if(x == y)
            return;

        if(_rank[x] < _rank[y])
        {
            _father[x] = y;
            _weight[y] += _weight[x];
        }
        else
        {
            _father[y] = x;
            _weight[x] += _weight[y];
            if(_rank[x] == _rank[y])
                ++_rank[x];
        }
    }

private:
    vector<int> _father;
    vector<int> _rank;
    vector<int> _weight;
    vector<int> _label;

    int _find(int x)
    {
        if(x == _father[x])
            return x;
        return _father[x] = _find(_father[x]);
    }
};

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        unordered_set<int> setting(initial.begin(), initial.end());
        UnionFindSet unionfindset(n);
        for(int i = 0; i < n - 1; ++i)
        {
            for(int j = i + 1; j < n; ++j)
            {
                if(graph[i][j] == 1 && setting.count(i) == 0 && setting.count(j) == 0)
                {
                    unionfindset.merge(i, j);
                }
            }
        }
        for(int i: initial)
        {
            for(int j = 0; j < n; ++j)
            {
                if(i == j) continue;
                if(setting.count(j) > 0)
                    continue;
                if(graph[i][j] == 0)
                    continue;
                unionfindset.set_label(j);
            }
        }

        int ans = -1;
        int max_cand = -1;
        for(int i: initial)
        {
            int cand = 0;
            for(int j = 0; j < n; ++j)
            {
                if(i == j) continue;
                if(setting.count(j) > 0) continue;
                if(graph[i][j] == 0)
                    continue;
                if(unionfindset.get_label(j) == 1)
                {
                    int cc = unionfindset.get_weight(j);
                    cand += cc;
                }

            }
            if(cand > max_cand)
            {
                max_cand = cand;
                ans = i;
            }
            else if(cand == max_cand && i < ans)
                ans = i;
        }
        return ans;
    }
};
